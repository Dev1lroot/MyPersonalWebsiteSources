import {
  require_three
} from "./chunk-GEFYRFNB.js";
import {
  __commonJS
} from "./chunk-Y2F7D3TJ.js";

// node_modules/@seregpie/three.text-texture/index.js
var require_three2 = __commonJS({
  "node_modules/@seregpie/three.text-texture/index.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require_three()) : "function" == typeof define && define.amd ? define(["three"], e) : ((t = "undefined" != typeof globalThis ? globalThis : t || self).THREE = t.THREE || {}, t.THREE.TextTexture = e(t.THREE));
    }(exports, function(t) {
      "use strict";
      let e = class extends t.Texture {
        constructor() {
          super(document.createElement("canvas"));
          let e2 = null, i2 = () => e2 || (e2 = this.createDrawable()), n = () => i2().width, o = () => i2().height, r = true, l = 1, a = () => t.MathUtils.ceilPowerOfTwo(n() * l), s = () => t.MathUtils.ceilPowerOfTwo(o() * l), h = (t2) => {
            if (l !== t2) {
              let e3 = a(), i3 = s();
              l = t2;
              let n2 = a(), o2 = s();
              n2 === e3 && o2 === i3 || (r = true);
            }
          }, c = (() => {
            let e3 = new t.Vector3(), i3 = new t.Vector2(), r2 = new t.Vector3(), l2 = new t.Vector3(), a2 = new t.Vector2();
            return (s2, h2, c2) => {
              if (a2.set(n(), o()), a2.x && a2.y) {
                s2.getWorldPosition(r2), c2.getWorldPosition(e3);
                let n2 = r2.distanceTo(e3);
                if (c2.isPerspectiveCamera && (n2 *= 2 * Math.tan(t.MathUtils.degToRad(c2.fov) / 2)), (c2.isPerspectiveCamera || c2.isOrthographicCamera) && (n2 /= c2.zoom), n2) {
                  var f, d;
                  s2.getWorldScale(l2);
                  let t2 = null !== (f = null === (d = h2.capabilities) || void 0 === d ? void 0 : d.maxTextureSize) && void 0 !== f ? f : 1 / 0;
                  return h2.getDrawingBufferSize(i3), Math.min(Math.max(l2.x / n2 * (i3.x / a2.x), l2.y / n2 * (i3.y / a2.y)), t2 / a2.x, t2 / a2.y);
                }
              }
              return 0;
            };
          })();
          Object.defineProperties(this, { width: { get: n }, height: { get: o }, pixelRatio: { get: () => l, set: h }, needsRedraw: { set(t2) {
            t2 && (r = true, e2 = null);
          } } }), Object.assign(this, { redraw() {
            if (r) {
              let t2 = this.image, e3 = t2.getContext("2d");
              e3.clearRect(0, 0, t2.width, t2.height), t2.width = a(), t2.height = s(), t2.width && t2.height ? (e3.save(), e3.scale(t2.width / n(), t2.height / o()), ((...t3) => {
                i2().draw(...t3);
              })(e3), e3.restore()) : t2.width = t2.height = 1, r = false, this.needsUpdate = true;
            }
          }, setOptimalPixelRatio(...t2) {
            h(c(...t2));
          } });
        }
      };
      e.prototype.isDynamicTexture = true;
      let i = class extends e {
        constructor({ alignment: t2 = "center", backgroundColor: e2 = "rgba(0,0,0,0)", color: i2 = "#fff", fontFamily: n = "sans-serif", fontSize: o = 16, fontStyle: r = "normal", fontVariant: l = "normal", fontWeight: a = "normal", lineGap: s = 1 / 4, padding: h = 0.5, strokeColor: c = "#fff", strokeWidth: f = 0, text: d = "" } = {}) {
          super(), Object.entries({ alignment: t2, backgroundColor: e2, color: i2, fontFamily: n, fontSize: o, fontStyle: r, fontVariant: l, fontWeight: a, lineGap: s, padding: h, strokeColor: c, strokeWidth: f, text: d }).forEach(([t3, e3]) => {
            Object.defineProperty(this, t3, { get: () => e3, set(t4) {
              e3 !== t4 && (e3 = t4, this.needsRedraw = true);
            } });
          });
        }
        get lines() {
          let { text: t2 } = this;
          return t2 ? t2.split("\n") : [];
        }
        get font() {
          return function(t2, e2, i2, n, o) {
            let r = document.createElement("span");
            return r.style.font = "1px serif", r.style.fontFamily = t2, r.style.fontSize = "".concat(e2, "px"), r.style.fontStyle = i2, r.style.fontVariant = n, r.style.fontWeight = o, r.style.font;
          }(this.fontFamily, this.fontSize, this.fontStyle, this.fontVariant, this.fontWeight);
        }
        checkFontFace() {
          try {
            let { font: t2 } = this;
            return document.fonts.check(t2);
          } catch {
          }
          return true;
        }
        async loadFontFace() {
          try {
            let { font: t2 } = this;
            await document.fonts.load(t2);
          } catch {
          }
        }
        createDrawable() {
          let { alignment: t2, backgroundColor: e2, color: i2, font: n, fontSize: o, lineGap: r, lines: l, padding: a, strokeColor: s, strokeWidth: h } = this;
          a *= o, r *= o, h *= o;
          let c = l.length, f = o + r, d = c ? (() => {
            let t3 = document.createElement("canvas").getContext("2d");
            return t3.font = n, Math.max(...l.map((e3) => t3.measureText(e3).width));
          })() : 0, g = a + h / 2, u = d + 2 * g;
          return { width: u, height: (c ? o + f * (c - 1) : 0) + 2 * g, draw(r2) {
            let a2;
            r2.fillStyle = e2, r2.fillRect(0, 0, r2.canvas.width, r2.canvas.height);
            let c2 = g + o / 2;
            Object.assign(r2, { fillStyle: i2, font: n, lineWidth: h, miterLimit: 1, strokeStyle: s, textAlign: (() => {
              switch (t2) {
                case "left":
                  return a2 = g, "left";
                case "right":
                  return a2 = u - g, "right";
              }
              return a2 = u / 2, "center";
            })(), textBaseline: "middle" }), l.forEach((t3) => {
              r2.fillText(t3, a2, c2), h && r2.strokeText(t3, a2, c2), c2 += f;
            });
          } };
        }
      };
      return i.prototype.isTextTexture = true, i;
    });
  }
});

// node_modules/@seregpie/three.text-sprite/index.js
var require_three3 = __commonJS({
  "node_modules/@seregpie/three.text-sprite/index.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t(require_three(), require_three2()) : "function" == typeof define && define.amd ? define(["three", "@seregpie/three.text-texture"], t) : ((e = "undefined" != typeof globalThis ? globalThis : e || self).THREE = e.THREE || {}, e.THREE.TextSprite = t(e.THREE, e.THREE.TextTexture));
    }(exports, function(e, t) {
      "use strict";
      function i(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
      }
      var r = i(t);
      let o = class extends e.Sprite {
        constructor({ fontSize: t2 = 1, ...i2 } = {}, o2 = new e.SpriteMaterial({ depthWrite: false })) {
          super(o2);
          let a = new r.default({ fontSize: t2, ...i2 });
          this.material.map = a;
        }
        onBeforeRender(e2, t2, i2) {
          let { material: r2 } = this, { map: o2 } = r2;
          if (o2.checkFontFace()) {
            let { scale: t3 } = this, { height: r3, width: a } = o2;
            a && r3 ? (t3.setX(a).setY(r3), o2.setOptimalPixelRatio(this, e2, i2), o2.redraw()) : t3.setScalar(1);
          } else
            o2.loadFontFace();
        }
        dispose() {
          let { material: e2 } = this, { map: t2 } = e2;
          t2.dispose(), e2.dispose();
        }
      };
      return ["alignment", "backgroundColor", "color", "fontFamily", "fontSize", "fontStyle", "fontVariant", "fontWeight", "lineGap", "padding", "strokeColor", "strokeWidth", "text"].forEach((e2) => {
        Object.defineProperty(o.prototype, e2, { get() {
          return this.material.map[e2];
        }, set(t2) {
          this.material.map[e2] = t2;
        } });
      }), o.prototype.isTextSprite = true, o;
    });
  }
});
export default require_three3();
//# sourceMappingURL=@seregpie_three__text-sprite.js.map
